for (i in 1:length(datlist)){
#split the plotting window based on number of lambda values
dims=c(round(length(lam)+1)/2,2)
par(mfrow=c(round(length(lam)+1)/2,2))
# start the inner loop which evaluates the various lambda for each profile in your list
for(j in 1:length(lam)){
#select the lambda
y<- lam[j]
# Run the spline and compile the RMSE values in a table
DataSpline <- suppressMessages(ithir::ea_spline(datlist[[i]], var.name= var.name ,d = d,lam = y, vlow=vlow, vhigh = vhigh, show.progress=FALSE))
l_eval<- cbind(y, sum(DataSpline$splineFitError$rmse, na.rm=TRUE))
ifelse(exists('lam_sum'), lam_sum<- rbind(lam_sum,l_eval), lam_sum<- l_eval)
# we need to correct the issue with numbers coming out as characters, a workaround
DataSpline$obs.preds[,2]<- as.numeric(DataSpline$obs.preds[,2])
DataSpline$obs.preds[,3]<- as.numeric(DataSpline$obs.preds[,3])
DataSpline$obs.preds[,4]<- as.numeric(DataSpline$obs.preds[,4])
# we add the plotting function here
oss.plot_spl(splineOuts= DataSpline, d = d, maxd = 100, type = 3)
mtext(paste0("lambda = ",y),cex = 0.8)
#end of inner loop for testing the specified lambda values
}
# once the loop is done we can save the plot to png if the user wants them
if(save.plots==TRUE){
dev.copy(png, paste0(output_dir,"/Spline_", var.name, "_", names[i], ".png"), width=600, height=800)
if(!is.null(dev.list())) dev.off()}
# then you retrieve the optimal lambda for the site
if (nrow(lam_sum)==1) {z= as.numeric(lam_sum[1,1])
} else {
lam_sum<- lam_sum[order(lam_sum[,2]),]
z=as.numeric(lam_sum[1,1])}
# and now run the spline one last time with optimal lambda and commit it to a new list
splinelist[[i]] <- suppressMessages(ithir::ea_spline(datlist[[i]], var.name= var.name ,d = d,lam = z, vlow=vlow, vhigh = vhigh, show.progress=FALSE))
rm(lam_sum)
#store the lambda values being used for future reference
ifelse(exists('lamdf'), lamdf<- rbind(lamdf,z), lamdf<- z)
# end of the outer loop which is based on the number of unique sites
}
# convert the table of optimal lambda values to dataframe and name the column
rownames(lamdf)<- c(seq(1,nrow(lamdf),by=1))
lamdf<- as.data.frame(lamdf)
colnames(lamdf)<- "lambda"
#small loop to unlist the data into dataframes
for (i in 1:length(splinelist)){
temp1 <- splinelist[[i]][[1]]
temp2 <- splinelist[[i]][[2]]
temp3 <- splinelist[[i]][[3]]
temp4 <- splinelist[[i]][[4]]
ifelse(exists('harmonized'), harmonized<- rbind(harmonized,temp1), harmonized<- temp1)
ifelse(exists('obs'), obs<- rbind(obs,temp2), obs<- temp2)
ifelse(exists('rmse'), rmse<- rbind(rmse,temp3), rmse<- temp3)
ifelse(exists('var.1cm'), var.1cm<- cbind(var.1cm,temp4), var.1cm<- temp4)
colnames(harmonized)<- colnames(splinelist[[i]][[1]])
colnames(obs)<- colnames(splinelist[[i]][[2]])
}
# combine the dataframes into an output identical to ea_spline list object, except we add the lambda table
datlist<- list(harmonized, obs, rmse, var.1cm,lamdf)
names(datlist)<- c('harmonised', 'obs.preds', 'splineFitError','var.1cm','lambda')
datlist$obs.preds$SiteID<- as.factor(datlist$obs.preds$SiteID)
#datlist$obs.preds[,2]<- as.numeric(datlist$obs.preds[,2])
#datlist$obs.preds[,3]<- as.numeric(datlist$obs.preds[,3])
#datlist$obs.preds[,4]<- as.numeric(datlist$obs.preds[,4])
return(datlist)}
fit<- oss.optSpline(obj=profiles, var.name="pH_CaCl2",lam= c(10, 1, 0.1, 0.01, 0.01), d=t(c(0,5,15,30,60,100)),vlow= 0, vhigh= 9, save.plots=FALSE)
fit<- oss.optSpline(obj=profiles, var.name="pH_CaCl2",lam= c(10, 1, 0.1, 0.01, 0.001), d=t(c(0,5,15,30,60,100)),vlow= 0, vhigh= 9, save.plots=FALSE)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::run_examples()
load("~/R/dev/onsoilsurvey/data/KeeneSOC.rda")
View(KeeneSOC)
KeeneSOC$bestTune
oss.getCCC(KeeneSOC)
library(onsoilsurvey)
oss.getCCC(KeeneSOC)
oss.goofCaret(keeneSOC)
oss.goofCaret(KeeneSOC)
View(KeeneSOC$bestTune)
colnames(KeeneSOC$bestTune)
devtools::check()
x<-NULL
if(x == NULL) stop ("No predictions are saveed to the train object from caret, set savePredicitons argument to all or final")
if(is.null(x)) stop ("No predictions are saveed to the train object from caret, set savePredicitons argument to all or final")
if(is.null(x)) stop ("No predictions are saved to the train object from caret, set \'savePredictions\' argument to \'all\' or \'final\'")
if(is.null(x)) stop ("No predictions are saved to the train object from caret, set \'savePredictions\' argument to \'all\' or \'final\' in the trainControl")
devtools::document()
devtools::document()
library(devtools)
document()
test()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
library(RColorBrewer)
?brewer.pal
library(devtools)
library(roxygen2)
document(onsoilsurvey)
document(onsoilsurvey::oss.seq_vif)
devtools::check(onsoilsurvey)
setwd("E:/02_oss_package/got_tmp/onsoilsurvey")
document()
devtools::build()
devtools::check()
document()
devtools::check()
document()
document()
devtools::check()
devtools::load_all()
devtools::check()
library(devtools)
devtools::check()
document()
document()
devtools::check()
document()
devtools::check()
library(onsoilsurvey)
library(raster)
data(keene)
orig_pts <- raster::sampleRandom(x=keene, size=1000, na.rm=TRUE, sp=FALSE)
ras1 <- orig_pts + rnorm(orig_pts, mean=0, sd=5)
ras2 <- orig_pts + rnorm(orig_pts, mean=0, sd=5)
ras3 <- orig_pts + rnorm(orig_pts, mean=0, sd=5)
ras4 <- orig_pts + rnorm(orig_pts, mean=0, sd=10)
ras5 <- orig_pts + rnorm(orig_pts, mean=0, sd=10)
df <- data.frame(orig_pts, ras1, ras2, ras3, ras4, ras5)
random_rasters <- NULL
for(i in 1:10){
rand_ras <- rnorm(n=length(orig_pts), mean=mean(orig_pts), sd=10)
random_rasters <- cbind(random_rasters, rand_ras)
}
df <- cbind(df, random_rasters)
oss.seqvif(df, thresh=5, trace=T, show.R2.vals=T)
library(fmsb)
oss.seqvif(df, thresh=5, trace=T, show.R2.vals=T)
document()
devtools::check()
document()
devtools::check()
oss.seqvif(df, thresh=5, trace=T, show.R2.vals=T)
oss.seqvif <- function(cov_df, thresh, trace=F, show.R2.vals=F){
###Load required library or throw error
if(any(!'data.frame' %in% class(cov_df))){cov_df <- data.frame(cov_df)}
###Get initial vif value for each covariate and confirm that at least VIF is above threshold
vif_init <- NULL
for(covar in names(cov_df)){
regressors <- names(cov_df)[names(cov_df) != covar]
form <- formula(paste(covar, '~', paste(regressors, collapse = '+')))
vif_init <- rbind(vif_init, c(covar, fmsb::VIF(lm(form, data = cov_df))))
}
max_vif <- max(as.numeric(vif_init[,2]), na.rm = TRUE)
###If no values are above threshold, stop
if(max_vif < thresh){
print(vif_init)
message(paste("Error: All variables have VIF <", thresh, ", max VIF = ", round(max_vif,2),
". Returning table with VIF scores. Choose lower threshold to perform removal or keep all variables"))
return(vif_init)
}
###If at least one value is above threshold, run sequential VIF
else{
in_dat <- cov_df #create copy to iterate over
#Set empty vectors to store outputs
names_kept_vec <- NULL; names_rem_vec <- NULL; vif_dfs <- NULL
vif_rem_vals <- data.frame(Covariate = character(), VIF_at_removal = numeric()) #Setting as numeric doesn't really matter since it gets removed later
#Backwards selection of explanatory variables, stops when all VIF values are below 'thresh'
while(max_vif >= thresh){
if(ncol(in_dat) <= 2){print("Removed all covariates but two, stopping"); break} #If not enough covariates to do lm, stop - shouldn't this be 1?
vif_vals <- NULL
for(covar in names(in_dat)){
regressors <- names(in_dat)[names(in_dat) != covar]
form <- formula(paste(covar, '~', paste(regressors, collapse = '+')))
vif_vals <- rbind(vif_vals, c(covar, VIF(lm(form, data = in_dat))))
}
#Record max value
max_vif <- max(as.numeric(vif_vals[,2]), na.rm = TRUE)
#if(length(which(vif_vals[,2] == max_vif)) > 1){paste0("VIF scores tied, removing alphabetically")} #This should be incredibly rare/impossible
max_row <- which(vif_vals[,2] == max_vif)[1]
#We need this break so it doesn't remove the next variable below the threshold
if(max_vif<thresh) break
#Print output of each iteration
if(trace){print(vif_vals); cat('\n'); cat('removed: ', vif_vals[max_row,1], max_vif,'\n\n')}
#Record names you are removing
names_rem_vec = append(names_rem_vec, vif_vals[max_row,1])
#Record the VIF value that is being removed
vif_rem_vals <- rbind(vif_rem_vals, vif_vals[max_row,])
#Remove covariate from dataframe
in_dat <- in_dat[,!names(in_dat) == vif_vals[max_row,1]]
#Store VIF table
vif_dfs <- c(vif_dfs, list(vif_vals))
}
#Record names you are keeping
names_kept_vec <- names(in_dat)
#Update columns of vif_rem_vals with covariates that were not removed during VIF because either:
#they were below threshold or because lm breaks down with 2 covariates
colnames(vif_rem_vals) <- c("Covariate", "VIF_score_at_removal")
vif_rem_vals[,2] <- as.numeric(vif_rem_vals[,2])
below_rows = data.frame(Covariate = as.character(vif_dfs[[length(vif_dfs)]][,1]),
VIF_score_at_removal = as.numeric(vif_dfs[[length(vif_dfs)]][,2])
)
below_rows = below_rows[order(-below_rows$VIF_score_at_removal),][-1,] #remove first entry since it's already been removed
below_rows[,2] = NA
vif_rem_vals <- rbind(vif_rem_vals, below_rows)
#If you want R2 and pearson r values. Not sure how to best interpret these
if(show.R2.vals){vif_rem_vals$R2 <- 1 - 1/(vif_rem_vals$VIF_score_at_removal)
vif_rem_vals$r <- sqrt(vif_rem_vals$R2)}
#This list is ordered from first VIF to last VIF
#(i.e., first variables to be removed and first VIF tables run are at the start)
return(list(names_kept_vec, names_rem_vec, vif_rem_vals, vif_dfs))
}
}
oss.seqvif(df, thresh=5, trace=T, show.R2.vals=T)
?lm
?formula
?names
document()
rm(oss.seqvif)
document()
document()
devtools::check()
devtools::check()
document()
devtools::check()
document()
devtools::check()
data(keene)
orig_pts <- raster::sampleRandom(x=keene, size=1000, na.rm=TRUE, sp=FALSE)
ras1 <- orig_pts + rnorm(orig_pts, mean=0, sd=5)
ras2 <- orig_pts + rnorm(orig_pts, mean=0, sd=5)
ras3 <- orig_pts + rnorm(orig_pts, mean=0, sd=5)
ras4 <- orig_pts + rnorm(orig_pts, mean=0, sd=10)
ras5 <- orig_pts + rnorm(orig_pts, mean=0, sd=10)
df <- data.frame(orig_pts, ras1, ras2, ras3, ras4, ras5)
random_rasters <- NULL
for(i in 1:10){
rand_ras <- rnorm(n=length(orig_pts), mean=mean(orig_pts), sd=10)
random_rasters <- cbind(random_rasters, rand_ras)
}
df <- cbind(df, random_rasters)
oss.seqvif(cov_df=df, thresh=5, trace=T, show.R2.vals=T)
cov_df=df
thresh=5
trace=T
show.R2.vals=T
###Load required library or throw error
if(any(!'data.frame' %in% class(cov_df))){cov_df <- data.frame(cov_df)}
###Get initial vif value for each covariate and confirm that at least VIF is above threshold
vif_init <- NULL
for(covar in names(cov_df)){
regressors <- names(cov_df)[names(cov_df) != covar]
form <- stats::formula(paste(covar, '~', paste(regressors, collapse = '+')))
vif_init <- rbind(vif_init, c(covar, fmsb::VIF(stats::lm(form, data = cov_df))))
}
max_vif <- max(as.numeric(vif_init[,2]), na.rm = TRUE)
###If no values are above threshold, stop
if(max_vif < thresh){
print(vif_init)
message(paste("Error: All variables have VIF <", thresh, ", max VIF = ", round(max_vif,2),
". Returning table with VIF scores. Choose lower threshold to perform removal or keep all variables"))
return(vif_init)
}
###If at least one value is above threshold, run sequential VIF
else{
in_dat <- cov_df #create copy to iterate over
#Set empty vectors to store outputs
names_kept_vec <- NULL; names_rem_vec <- NULL; vif_dfs <- NULL
vif_rem_vals <- data.frame(Covariate = character(), VIF_at_removal = numeric()) #Setting as numeric doesn't really matter since it gets removed later
#Backwards selection of explanatory variables, stops when all VIF values are below 'thresh'
while(max_vif >= thresh){
if(ncol(in_dat) <= 2){print("Removed all covariates but two, stopping"); break} #If not enough covariates to do lm, stop - shouldn't this be 1?
vif_vals <- NULL
for(covar in names(in_dat)){
regressors <- names(in_dat)[names(in_dat) != covar]
form <- stats::formula(paste(covar, '~', paste(regressors, collapse = '+')))
vif_vals <- rbind(vif_vals, c(covar, fmsb::VIF(stats::lm(form, data = in_dat))))
}
#Record max value
max_vif <- max(as.numeric(vif_vals[,2]), na.rm = TRUE)
#if(length(which(vif_vals[,2] == max_vif)) > 1){paste0("VIF scores tied, removing alphabetically")} #This should be incredibly rare/impossible
max_row <- which(vif_vals[,2] == max_vif)[1]
#We need this break so it doesn't remove the next variable below the threshold
if(max_vif<thresh) break
#Print output of each iteration
if(trace){print(vif_vals); cat('\n'); cat('removed: ', vif_vals[max_row,1], max_vif,'\n\n')}
#Record names you are removing
names_rem_vec = append(names_rem_vec, vif_vals[max_row,1])
#Record the VIF value that is being removed
vif_rem_vals <- rbind(vif_rem_vals, vif_vals[max_row,])
#Remove covariate from dataframe
in_dat <- in_dat[,!names(in_dat) == vif_vals[max_row,1]]
#Store VIF table
vif_dfs <- c(vif_dfs, list(vif_vals))
}
#Record names you are keeping
names_kept_vec <- names(in_dat)
#Update columns of vif_rem_vals with covariates that were not removed during VIF because either:
#they were below threshold or because lm breaks down with 2 covariates
colnames(vif_rem_vals) <- c("Covariate", "VIF_score_at_removal")
vif_rem_vals[,2] <- as.numeric(vif_rem_vals[,2])
below_rows = data.frame(Covariate = as.character(vif_dfs[[length(vif_dfs)]][,1]),
VIF_score_at_removal = as.numeric(vif_dfs[[length(vif_dfs)]][,2])
)
below_rows = below_rows[order(-below_rows$VIF_score_at_removal),][-1,] #remove first entry since it's already been removed
below_rows[,2] = NA
vif_rem_vals <- rbind(vif_rem_vals, below_rows)
#If you want R2 and pearson r values. Not sure how to best interpret these
if(show.R2.vals){vif_rem_vals$R2 <- 1 - 1/(vif_rem_vals$VIF_score_at_removal)
vif_rem_vals$r <- sqrt(vif_rem_vals$R2)}
#This list is ordered from first VIF to last VIF
#(i.e., first variables to be removed and first VIF tables run are at the start)
return(list(names_kept_vec, names_rem_vec, vif_rem_vals, vif_dfs))
}
if(max_vif < thresh){
print(vif_init)
message(paste("Error: All variables have VIF <", thresh, ", max VIF = ", round(max_vif,2),
". Returning table with VIF scores. Choose lower threshold to perform removal or keep all variables"))
return(vif_init)
}
###If at least one value is above threshold, run sequential VIF
else{
in_dat <- cov_df #create copy to iterate over
#Set empty vectors to store outputs
names_kept_vec <- NULL; names_rem_vec <- NULL; vif_dfs <- NULL
vif_rem_vals <- data.frame(Covariate = character(), VIF_at_removal = numeric()) #Setting as numeric doesn't really matter since it gets removed later
#Backwards selection of explanatory variables, stops when all VIF values are below 'thresh'
while(max_vif >= thresh){
if(ncol(in_dat) <= 2){print("Removed all covariates but two, stopping"); break} #If not enough covariates to do lm, stop - shouldn't this be 1?
vif_vals <- NULL
for(covar in names(in_dat)){
regressors <- names(in_dat)[names(in_dat) != covar]
form <- stats::formula(paste(covar, '~', paste(regressors, collapse = '+')))
vif_vals <- rbind(vif_vals, c(covar, fmsb::VIF(stats::lm(form, data = in_dat))))
}
#Record max value
max_vif <- max(as.numeric(vif_vals[,2]), na.rm = TRUE)
#if(length(which(vif_vals[,2] == max_vif)) > 1){paste0("VIF scores tied, removing alphabetically")} #This should be incredibly rare/impossible
max_row <- which(vif_vals[,2] == max_vif)[1]
#We need this break so it doesn't remove the next variable below the threshold
if(max_vif<thresh) break
#Print output of each iteration
if(trace){print(vif_vals); cat('\n'); cat('removed: ', vif_vals[max_row,1], max_vif,'\n\n')}
#Record names you are removing
names_rem_vec = append(names_rem_vec, vif_vals[max_row,1])
#Record the VIF value that is being removed
vif_rem_vals <- rbind(vif_rem_vals, vif_vals[max_row,])
#Remove covariate from dataframe
in_dat <- in_dat[,!names(in_dat) == vif_vals[max_row,1]]
#Store VIF table
vif_dfs <- c(vif_dfs, list(vif_vals))
}
#Record names you are keeping
names_kept_vec <- names(in_dat)
#Update columns of vif_rem_vals with covariates that were not removed during VIF because either:
#they were below threshold or because lm breaks down with 2 covariates
colnames(vif_rem_vals) <- c("Covariate", "VIF_score_at_removal")
vif_rem_vals[,2] <- as.numeric(vif_rem_vals[,2])
below_rows = data.frame(Covariate = as.character(vif_dfs[[length(vif_dfs)]][,1]),
VIF_score_at_removal = as.numeric(vif_dfs[[length(vif_dfs)]][,2])
)
below_rows = below_rows[order(-below_rows$VIF_score_at_removal),][-1,] #remove first entry since it's already been removed
below_rows[,2] = NA
vif_rem_vals <- rbind(vif_rem_vals, below_rows)
#If you want R2 and pearson r values. Not sure how to best interpret these
if(show.R2.vals){vif_rem_vals$R2 <- 1 - 1/(vif_rem_vals$VIF_score_at_removal)
vif_rem_vals$r <- sqrt(vif_rem_vals$R2)}
#This list is ordered from first VIF to last VIF
#(i.e., first variables to be removed and first VIF tables run are at the start)
return(list(names_kept_vec, names_rem_vec, vif_rem_vals, vif_dfs))
return(list(names_kept_vec, names_rem_vec, vif_rem_vals, vif_dfs))
oss.seqvif <- function(cov_df, thresh, trace=F, show.R2.vals=F){
###Load required library or throw error
if(any(!'data.frame' %in% class(cov_df))){cov_df <- data.frame(cov_df)}
###Get initial vif value for each covariate and confirm that at least VIF is above threshold
vif_init <- NULL
for(covar in names(cov_df)){
regressors <- names(cov_df)[names(cov_df) != covar]
form <- stats::formula(paste(covar, '~', paste(regressors, collapse = '+')))
vif_init <- rbind(vif_init, c(covar, fmsb::VIF(stats::lm(form, data = cov_df))))
}
max_vif <- max(as.numeric(vif_init[,2]), na.rm = TRUE)
###If no values are above threshold, stop
if(max_vif < thresh){
print(vif_init)
message(paste("Error: All variables have VIF <", thresh, ", max VIF = ", round(max_vif,2),
". Returning table with VIF scores. Choose lower threshold to perform removal or keep all variables"))
return(vif_init)
}
###If at least one value is above threshold, run sequential VIF
else{
in_dat <- cov_df #create copy to iterate over
#Set empty vectors to store outputs
names_kept_vec <- NULL; names_rem_vec <- NULL; vif_dfs <- NULL
vif_rem_vals <- data.frame(Covariate = character(), VIF_at_removal = numeric()) #Setting as numeric doesn't really matter since it gets removed later
#Backwards selection of explanatory variables, stops when all VIF values are below 'thresh'
while(max_vif >= thresh){
if(ncol(in_dat) <= 2){print("Removed all covariates but two, stopping"); break} #If not enough covariates to do lm, stop - shouldn't this be 1?
vif_vals <- NULL
for(covar in names(in_dat)){
regressors <- names(in_dat)[names(in_dat) != covar]
form <- stats::formula(paste(covar, '~', paste(regressors, collapse = '+')))
vif_vals <- rbind(vif_vals, c(covar, fmsb::VIF(stats::lm(form, data = in_dat))))
}
#Record max value
max_vif <- max(as.numeric(vif_vals[,2]), na.rm = TRUE)
#if(length(which(vif_vals[,2] == max_vif)) > 1){paste0("VIF scores tied, removing alphabetically")} #This should be incredibly rare/impossible
max_row <- which(vif_vals[,2] == max_vif)[1]
#We need this break so it doesn't remove the next variable below the threshold
if(max_vif<thresh) break
#Print output of each iteration
if(trace){print(vif_vals); cat('\n'); cat('removed: ', vif_vals[max_row,1], max_vif,'\n\n')}
#Record names you are removing
names_rem_vec = append(names_rem_vec, vif_vals[max_row,1])
#Record the VIF value that is being removed
vif_rem_vals <- rbind(vif_rem_vals, vif_vals[max_row,])
#Remove covariate from dataframe
in_dat <- in_dat[,!names(in_dat) == vif_vals[max_row,1]]
#Store VIF table
vif_dfs <- c(vif_dfs, list(vif_vals))
}
#Record names you are keeping
names_kept_vec <- names(in_dat)
#Update columns of vif_rem_vals with covariates that were not removed during VIF because either:
#they were below threshold or because lm breaks down with 2 covariates
colnames(vif_rem_vals) <- c("Covariate", "VIF_score_at_removal")
vif_rem_vals[,2] <- as.numeric(vif_rem_vals[,2])
below_rows = data.frame(Covariate = as.character(vif_dfs[[length(vif_dfs)]][,1]),
VIF_score_at_removal = as.numeric(vif_dfs[[length(vif_dfs)]][,2])
)
below_rows = below_rows[order(-below_rows$VIF_score_at_removal),][-1,] #remove first entry since it's already been removed
below_rows[,2] = NA
vif_rem_vals <- rbind(vif_rem_vals, below_rows)
#If you want R2 and pearson r values. Not sure how to best interpret these
if(show.R2.vals){vif_rem_vals$R2 <- 1 - 1/(vif_rem_vals$VIF_score_at_removal)
vif_rem_vals$r <- sqrt(vif_rem_vals$R2)}
}
#This list is ordered from first VIF to last VIF
#(i.e., first variables to be removed and first VIF tables run are at the start)
return(list(names_kept_vec, names_rem_vec, vif_rem_vals, vif_dfs))
}
oss.seqvif(cov_df=df, thresh=5, trace=T, show.R2.vals=T)
devtools::document()
rm(oss.seqvif)
devtools::document()
devtools::check()
load_all()
#Generate autocorrelated raster layers from the Keene study area
data(keene)
##Original DEM values
orig_pts <- raster::sampleRandom(x=keene, size=1000, na.rm=TRUE, sp=FALSE)
##Create values correlated with original DEM values
ras1 <- orig_pts + rnorm(orig_pts, mean=0, sd=5)
ras2 <- orig_pts + rnorm(orig_pts, mean=0, sd=5)
ras3 <- orig_pts + rnorm(orig_pts, mean=0, sd=5)
ras4 <- orig_pts + rnorm(orig_pts, mean=0, sd=10)
ras5 <- orig_pts + rnorm(orig_pts, mean=0, sd=10)
df <- data.frame(orig_pts, ras1, ras2, ras3, ras4, ras5)
#Create values with same mean as DEM values but not correlated
random_rasters <- NULL
for(i in 1:10){
rand_ras <- rnorm(n=length(orig_pts), mean=mean(orig_pts), sd=10)
random_rasters <- cbind(random_rasters, rand_ras)
}
df <- cbind(df, random_rasters)
oss.seqvif(cov_df=df, thresh=5, trace=T, show.R2.vals=T)
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
library(devtools)
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::dcoument
devtools::document()
?oss.seqVIF
library(ithir)
$goof
?goof
?oss.seqVIF
devtools::document()
?oss.seqVIF
devtools::document()
devtools::document()
?oss.seqVIF
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
